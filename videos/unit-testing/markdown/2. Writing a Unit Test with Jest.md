# Writing a Unit Test with Jest

In this lesson, we‚Äôre going to write our first unit test using Jest and Vue Test Utils. You can get started with the starting code available in this page‚Äôs lesson resources, or you can follow along and create the project from scratch using the Vue CLI.

---

## Creating Our Project

We‚Äôll create a new project using the Vue CLI. From the command line run the following command:

`vue create unit-testing-vue`

We‚Äôll choose ‚ÄúManually select features‚Äù and click **enter** so that we can specify which libraries we want to include in our new project. Since we will be learning how to test with **Vue Router** and **Vuex**, we‚Äôll select both of those and of course we need to select **Unit Testing.** This will add the appropriate libraries to our project.

In the previous step, **Linter / Formatter** was selected by default, the next step allows us to customize that feature. For those, I selected **ESLint + Prettier**, and **Lint on save**. This configuration is totally up to you for this project.

Because we selected **Unit Testing** as a feature to include in our project, the next step asks what library we want to use for Unit Testing. We are going to use **Jest**.

We are going to put all of our configuration in their own dedicated files so you can leave the default here and press **enter**.

If you want to save this as a preset you can, if not type **n** and press **enter**. Our project will then be built for us.

---

## Touring the Project Structure

With the project open, let‚Äôs start out by looking into the **package.json**, where we‚Äôll see that Jest and vue-test-utils were installed for us.

üìÉ**package.json**

```JSON
"devDependencies": {
  "@vue/cli-plugin-unit-jest": "^3.11.0",
  "@vue/test-utils": "1.0.0-beta.29"
}

```

What do these libraries do again? As a reminder:

[Jest](https://jestjs.io/) is a JavaScript testing framework that focuses on simplifying your unit tests. Jest will run the unit tests for us and report back to us if the test passed or failed. While Jest is a pretty large framework (there are entire books written on the subject), you will only need to understand a few pieces to write some basic tests.

[Vue Test Utils](https://vue-test-utils.vuejs.org/) is the official unit testing utility library for Vue.js. It gives us the ability to render our components in our tests and then perform various operations on those rendered components. This is crucial for determining the actual results from a component‚Äôs behavior.

Great. We have the proper testing tools installed. But how do we get them to work? Notice this script command within our **package.json**:

üìÉ**package.json**

```JSON
"scripts": {
  ...
  "test:unit": "vue-cli-service test:unit"
},

```

This command essentially looks into the directory called **tests / unit** and runs the tests we‚Äôve set up in our **ComponentName.spec.js** files.

If we look inside our **tests / unit** directory, we‚Äôll find an **Example.spec.js** file that was created for us. This is a dummy test file that is testing the **HelloWorld.vue** component in our **src/components** directory. For now, we‚Äôll ignore what‚Äôs written inside that **Example.spec.js** file and go straight to our terminal and enter `npm run test:unit`

When we do that, we‚Äôll see that the test within **Example.spec.js is** being run and it passes.

![https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1580172695631_1.opt.png?alt=media&token=3d8a7538-da9b-4369-95f2-00fedc11d1c8](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1580172695631_1.opt.png?alt=media&token=3d8a7538-da9b-4369-95f2-00fedc11d1c8)

This is what we‚Äôre going to learn how to do by the end of this lesson. We‚Äôll create a new component, set up some tests for it, and run those tests using the `test:unit` script command.

---

## A new component and testing file

Before writing any tests, we need a component to test. So we‚Äôll delete out the **HelloWorld.vue** component in **src/components** and then create a new file called **AppHeader.vue**, which looks like this:

üìÉ**AppHeader.vue**

```html
<template>
  <div>
    <button v-show="loggedIn">Logout</button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      loggedIn: false
    }
  }
}
</script>

```

This component should look pretty familiar because we used it as an example in the previous lesson. It is a simple App Header that displays a Logout button when a user is `loggedIn`.

Now that we have a component to test, we can head into our **test / unit** directory, delete out the example testing file and create a new one called **AppHeader.spec.js**. As you can see in the naming convention here, we are using the name of the component we‚Äôre testing **AppHeader** \+ **spec.js**. Spec stands for specification because in this file we are essentially _specifying_ how the **AppHeader** component ought to behave, and testing that behavior.

Note that these file names _must_ include ‚Äúspec.js‚Äù ‚Äî without it, they won‚Äôt be run when we use the `npm run test:unit` script.

---

## Identifying what to test

Before we can write tests for our **AppHeader.vue** component, we need to identify its **inputs** and **outputs**. Fortunately, we already covered that in the previous lesson.

**Inputs**

* Data: `loggedIn` \- This data property determines if the button shows or not

**Outputs**

* Rendered Output: `<button>` \- Based on the `loggedIn` input, is our button displayed in the DOM or not

We know that when `loggedIn` equals false (default), the Logout button is not displayed in the DOM. When `loggedIn` equals true, then the Logout button is displayed.

So our tests for this component are:

1. If user is not logged in, do not show logout button
2. If user is logged in, show logout button

---

## Scaffolding our first unit test

Now that we know what we‚Äôre testing, we can head into our **AppHeader.spec.js** file and start writing our tests. First, we‚Äôll need to import the component that we‚Äôre testing.

üìÉ**AppHeader.spec.js**

```javascript
import AppHeader from '@/components/AppHeader'

```

Now we can create our first test block by using the Jest `describe()` function.

üìÉ**AppHeader.spec.js**

```javascript
describe('AppHeader', () => {

})

```

A describe block allows us to group related tests. When we run our tests we will see the name of the describe block printed in the console. As its arguments, `describe()` takes a string for the name of the component along with a function where the tests will go. It‚Äôs worth noting here that if we only have one test we don‚Äôt need to wrap it in a describe block. But when we have multiple tests, it‚Äôs helpful to organize them in this way.

Now that we have a grouping for our tests, we can start writing those individual tests. We do this by using the Jest `test()` method. For its arguments, the [test method](https://jestjs.io/docs/en/api#testname-fn-timeout) takes a string to define the test and a function where the actual testing logic will go.

üìÉ**AppHeader.spec.js**

```javascript
test('a simple string that defines your test', () => {
  // testing logic
}

```

TIP: You might also see test blocks that use `it()` and this will also work because it‚Äôs an alias for `test()`.

So our two tests will start out looking like this:

üìÉ**AppHeader.spec.js**

```javascript
test('if user is not logged in, do not show logout button', () => {
  // test body
})

test('if a user is logged in, show logout button', () => {
  // test body
})

```

So we have the tests set up, but they don‚Äôt do anything yet. We need to add some logic in the body of them to determine if the actual result matches the result we are expecting.

---

### **Asserting Expectations**

In Jest, we use assertions to determine whether what we _expect_ the test to return matches what is actually returned. Specifically, we do this by using Jest‚Äôs `expect()` method, which gives us access to a number of ‚Äúmatchers‚Äù that help us match the actual result against the expected result.

The syntax for an assertion basically works like this:

`expect(theResult).toBe(true)`

Inside the `expect()` method, we‚Äôre putting the result itself that we‚Äôre testing. We then use a **matcher** to determine if that result is what we expected it to be. So here, we‚Äôre using the common Jest matcher `toBe()` to say: we expect the result to be true.

When writing tests, it‚Äôs helpful to first write a test that you know will definitely pass (or definitely fail). For example, if we say: `expect(true).toBe(true)` we know this will definitely pass. The result that‚Äôs passed into `expect()` is `true` and we are saying we expect that result `toBe` `true`. So if we were to run these tests, we know they will definitely pass because `true` \== `true`.

üìÉ**AppHeader.spec.js**

```javascript
describe('AppHeader', () => {
  test('if a user is not logged in, do not show the logout button', () => {
    expect(true).toBe(true)
  })
  
  test('if a user is logged in, show the logout button', () => {
    expect(true).toBe(true)
  })
})

```

If these tests don‚Äôt pass, then we know we‚Äôve set something else up wrong elsewhere in our code. So writing this kind of test serves as a form of sanity test for us, preventing us from wasting time debugging our testing code when tests that should be passing are not.

Understanding how to write tests means understanding what matchers are available to you, so take some time to understand [the Jest Matchers API](https://jestjs.io/docs/en/expect).

---

## The Power of Vue Test Utils

Now that we‚Äôve scaffolded our tests, and got them both passing, we can switch out that ‚Äúsanity test‚Äù with the real logic that can perform our given tests:

1. If a user is not logged in, do not show the logout button
2. If a user is logged in, show the logout button

In order to do this, we need the **AppHeader** component to be mounted (to check if the button is visible in the DOM or not). This would be quite a process to perform all on our own, but fortunately with the help of Vue Test Utils, it‚Äôs very simple because this library comes packaged with `mount`.

So let‚Äôs import `mount` into our testing file and see what it can do for us.

üìÉ**AppHeader.spec.js**

```javascript
import { mount } from '@vue/test-utils'
import AppHeader from '@/components/AppHeader'

describe('AppHeader', () => {
  test('if user is not logged in, do not show logout button', () => {
    const wrapper = mount(AppHeader) // mounting the component 
    expect(true).toBe(true)
  })
  
  test('if user is logged in, show logout button', () => {
    const wrapper = mount(AppHeader) // mounting the component 
    expect(true).toBe(true)
  })
})

```

Above, in each of our tests we‚Äôve created a `wrapper` const in which we `mount(AppHeader)`. The reason we‚Äôre calling it `wrapper` is because in addition to mounting the component, this method creates a [wrapper](https://vue-test-utils.vuejs.org/api/wrapper/) that includes methods to test the component. Of course, it‚Äôs helpful to understand the different properties and methods on the wrapper, so take some time to explore [the documentation](https://vue-test-utils.vuejs.org/api/wrapper/).

**Sidenote:** In the Vue Test Utils you will also find the method `shallowMount()`. If your component has children, `shallowMount()` will return a simple implementation of that component instead of a fully rendered version. This is important because the focus of a unit test is the component in isolation and not the children of that component.

We‚Äôre still not performing our actual tests yet, but now we have a `wrapper` of the mounted AppHeader component, which we can use to write out the complete tests.

---

### Testing the Button‚Äôs visibility

In our first test case, we know that by default the user is not logged in (our input is `loggedIn: false`) so we want to check and make sure the logout button is not visible.

To make assertions on the state of the logout button, we‚Äôll need to get a reference to the button element that is defined in the template. To accomplish this we will rely on two methods available to us on our new **wrapper**: `find()` and `isVisible()`. The `find()` method will search through our template for a matching selector in order to locate our button, and `isVisible()` will return a boolean, telling us if that button is visible in our component or not.

So our first test will look like:

üìÉ**AppHeader.spec.js**

```javascript
  test('if user is not logged in, do not show logout button', () => {
    const wrapper = mount(AppHeader)
    expect(wrapper.find('button').isVisible()).toBe(false)
  })

```

For our second test, we want to find the button in the same way, but this time we expect it to be visible, so we‚Äôll say: `toBe(true)`.

üìÉ**AppHeader.spec.js**

```javascript
	test("if logged in, show logout button", () => {
    const wrapper = mount(AppHeader)
    expect(wrapper.find('button').isVisible()).toBe(true)
  })

```

Because we are testing the components behavior when we have a user (when `loggedIn` is `true`), we need to update that value or else this test will fail. How we do we this? Vue Test Utils to the rescue!

üìÉ**AppHeader.spec.js**

```javascript
test("if logged in, show logout button", () => {
    const wrapper = mount(AppHeader)
    wrapper.setData({ loggedIn: true }) // setting our data value
    expect(wrapper.find('button').isVisible()).toBe(true)
  })

```

Here, we‚Äôre using the **wrapper**‚Äôs built-in `setData()` method to set our data to fit the correct scenario that we‚Äôre testing. However, if we were to run this test, it would fail. That‚Äôs because when we set the data, this triggers DOM updates, and we need to wait for those updates to happen, otherwise we can‚Äôt be sure that we‚Äôre testing the final rendered results. To accomplish this, we‚Äôll need to make this test asynchronous using `async` / `await`, and rely on `$nextTick()`, like so:

```javascript
test("if logged in, show logout button", async () => {
    const wrapper = mount(AppHeader)
    wrapper.setData({ loggedIn: true }) // setting our data value

    await wrapper.vm.$nextTick() 
    expect(wrapper.find('button').isVisible()).toBe(true)
  })

```

Now, when we run our tests in the terminal with `npm run test:unit`, they should both be passing!

---

## Let‚Äôs ReVue

We just covered a lot of steps, as a recap here is what we just did:

![https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1580172592082_2.opt.jpg?alt=media&token=a909a1cb-a94f-4a93-9a74-74dbc875a559](https://firebasestorage.googleapis.com/v0/b/vue-mastery.appspot.com/o/flamelink%2Fmedia%2F1580172592082_2.opt.jpg?alt=media&token=a909a1cb-a94f-4a93-9a74-74dbc875a559)

Obviously, every component that we are testing is a bit different so these steps may change, especially step 4\. Instead of setting the data, we may need to set the props, or simulate user interaction, for example. And we‚Äôll cover more of these test cases in future lessons.